---
globs: *.tsx,*.jsx
description: Prefer functional components in React
---

# React Functional Components

Always prefer functional components over class components in React.

## Guidelines

- **Use functional components** with hooks instead of class components
- **Use React.FC** or explicit return type annotations for TypeScript
- **Use hooks** for state management (`useState`, `useReducer`)
- **Use hooks** for side effects (`useEffect`, `useLayoutEffect`)
- **Use custom hooks** for reusable logic
- **Avoid class components** unless absolutely necessary for legacy compatibility

## Examples

### Correct Functional Component Usage

```typescript
import React, { useState, useEffect } from 'react';

interface UserProfileProps {
  userId: string;
  onUpdate?: (user: User) => void;
}

const UserProfile: React.FC<UserProfileProps> = ({ userId, onUpdate }) => {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const fetchUser = async () => {
      try {
        setLoading(true);
        const userData = await getUserById(userId);
        setUser(userData);
      } catch (error) {
        console.error('Failed to fetch user:', error);
      } finally {
        setLoading(false);
      }
    };

    fetchUser();
  }, [userId]);

  const handleUpdate = (updatedUser: User) => {
    setUser(updatedUser);
    onUpdate?.(updatedUser);
  };

  if (loading) return <div>Loading...</div>;
  if (!user) return <div>User not found</div>;

  return (
    <div>
      <h1>{user.name}</h1>
      <p>{user.email}</p>
    </div>
  );
};

export default UserProfile;
```

### Custom Hook Example

```typescript
import { useState, useEffect } from "react";

interface UseUserReturn {
  user: User | null;
  loading: boolean;
  error: string | null;
  refetch: () => void;
}

const useUser = (userId: string): UseUserReturn => {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchUser = async () => {
    try {
      setLoading(true);
      setError(null);
      const userData = await getUserById(userId);
      setUser(userData);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to fetch user");
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchUser();
  }, [userId]);

  return { user, loading, error, refetch: fetchUser };
};
```

### Avoid Class Components

```typescript
// ‚ùå Don't use class components
class UserProfile extends React.Component<UserProfileProps, UserProfileState> {
  constructor(props: UserProfileProps) {
    super(props);
    this.state = {
      user: null,
      loading: true,
    };
  }

  componentDidMount() {
    this.fetchUser();
  }

  fetchUser = async () => {
    // ... implementation
  };

  render() {
    // ... render logic
  }
}
```

## Hook Guidelines

- **useState**: For local component state
- **useEffect**: For side effects and lifecycle events
- **useContext**: For consuming React context
- **useMemo**: For expensive calculations
- **useCallback**: For memoizing functions
- **Custom hooks**: For reusable stateful logic

## TypeScript Integration

- Use `React.FC<Props>` for component type annotation
- Define proper interfaces for props
- Use generic types when appropriate
- Leverage TypeScript's strict mode for better type safety
