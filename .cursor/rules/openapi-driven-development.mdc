---
globs: *.ts,*.tsx,*.yaml,*.yml
description: Follow OpenAPI-driven development: update spec first, generate types, then implement
---

# OpenAPI-Driven Development

Always follow OpenAPI-driven development workflow: update the OpenAPI specification first, generate types, then implement the code.

## Workflow

1. **Design API** - Update OpenAPI specification
2. **Generate Types** - Generate TypeScript types from spec
3. **Implement** - Write code using generated types
4. **Validate** - Ensure implementation matches specification

## File Structure

```
openapi/
├── openapi.yaml          # Main OpenAPI specification
├── dist/
│   └── openapi.yaml      # Bundled specification
├── components/
│   ├── schemas/          # Reusable schemas
│   ├── responses/        # Common responses
│   └── parameters/       # Common parameters
└── paths/
    ├── auth.yaml         # Authentication endpoints
    ├── users.yaml        # User management endpoints
    └── posts.yaml        # Post management endpoints
```

## OpenAPI Specification Example

```yaml
# openapi/openapi.yaml
openapi: 3.0.3
info:
  title: HavenHost Admin API
  description: Admin API for HavenHost platform
  version: 1.0.0
  contact:
    name: API Support
    email: support@havenhost.com

servers:
  - url: https://api.havenhost.com/v1
    description: Production server
  - url: http://localhost:3000/api/v1
    description: Development server

paths:
  /users:
    get:
      summary: List users
      description: Retrieve a paginated list of users
      tags:
        - Users
      parameters:
        - $ref: "#/components/parameters/PageParam"
        - $ref: "#/components/parameters/LimitParam"
        - $ref: "#/components/parameters/SearchParam"
      responses:
        "200":
          description: Successful response
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/UserListResponse"
        "400":
          $ref: "#/components/responses/BadRequest"
        "401":
          $ref: "#/components/responses/Unauthorized"
        "500":
          $ref: "#/components/responses/InternalServerError"

    post:
      summary: Create user
      description: Create a new user account
      tags:
        - Users
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: "#/components/schemas/CreateUserRequest"
      responses:
        "201":
          description: User created successfully
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/UserResponse"
        "400":
          $ref: "#/components/responses/BadRequest"
        "409":
          $ref: "#/components/responses/Conflict"

  /users/{userId}:
    get:
      summary: Get user
      description: Retrieve a specific user by ID
      tags:
        - Users
      parameters:
        - $ref: "#/components/parameters/UserIdParam"
      responses:
        "200":
          description: Successful response
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/UserResponse"
        "404":
          $ref: "#/components/responses/NotFound"

    put:
      summary: Update user
      description: Update an existing user
      tags:
        - Users
      parameters:
        - $ref: "#/components/parameters/UserIdParam"
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: "#/components/schemas/UpdateUserRequest"
      responses:
        "200":
          description: User updated successfully
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/UserResponse"
        "404":
          $ref: "#/components/responses/NotFound"

    delete:
      summary: Delete user
      description: Delete a user account
      tags:
        - Users
      parameters:
        - $ref: "#/components/parameters/UserIdParam"
      responses:
        "204":
          description: User deleted successfully
        "404":
          $ref: "#/components/responses/NotFound"

components:
  schemas:
    User:
      type: object
      required:
        - id
        - first_name
        - last_name
        - email_address
        - created_at
        - updated_at
        - is_active
      properties:
        id:
          type: integer
          format: int64
          example: 1
        first_name:
          type: string
          minLength: 1
          maxLength: 255
          example: "John"
        last_name:
          type: string
          minLength: 1
          maxLength: 255
          example: "Doe"
        email_address:
          type: string
          format: email
          maxLength: 255
          example: "john.doe@example.com"
        role:
          type: string
          enum: [admin, editor, viewer]
          default: viewer
          example: "editor"
        is_active:
          type: boolean
          default: true
          example: true
        created_at:
          type: string
          format: date-time
          example: "2024-01-15T10:30:00Z"
        updated_at:
          type: string
          format: date-time
          example: "2024-01-15T10:30:00Z"

    CreateUserRequest:
      type: object
      required:
        - first_name
        - last_name
        - email_address
      properties:
        first_name:
          type: string
          minLength: 1
          maxLength: 255
          example: "John"
        last_name:
          type: string
          minLength: 1
          maxLength: 255
          example: "Doe"
        email_address:
          type: string
          format: email
          maxLength: 255
          example: "john.doe@example.com"
        role:
          type: string
          enum: [admin, editor, viewer]
          default: viewer
          example: "editor"

    UpdateUserRequest:
      type: object
      properties:
        first_name:
          type: string
          minLength: 1
          maxLength: 255
          example: "John"
        last_name:
          type: string
          minLength: 1
          maxLength: 255
          example: "Doe"
        email_address:
          type: string
          format: email
          maxLength: 255
          example: "john.doe@example.com"
        role:
          type: string
          enum: [admin, editor, viewer]
          example: "editor"
        is_active:
          type: boolean
          example: true

    UserResponse:
      type: object
      properties:
        success:
          type: boolean
          example: true
        data:
          $ref: "#/components/schemas/User"

    UserListResponse:
      type: object
      properties:
        success:
          type: boolean
          example: true
        data:
          type: array
          items:
            $ref: "#/components/schemas/User"
        pagination:
          $ref: "#/components/schemas/Pagination"

    Pagination:
      type: object
      properties:
        page:
          type: integer
          minimum: 1
          example: 1
        limit:
          type: integer
          minimum: 1
          maximum: 100
          example: 20
        total:
          type: integer
          example: 150
        total_pages:
          type: integer
          example: 8

    ErrorResponse:
      type: object
      properties:
        success:
          type: boolean
          example: false
        error:
          type: string
          example: "Validation failed"
        details:
          type: array
          items:
            type: string
          example:
            ["Email is required", "First name must be at least 1 character"]

  parameters:
    UserIdParam:
      name: userId
      in: path
      required: true
      schema:
        type: integer
        format: int64
      example: 1

    PageParam:
      name: page
      in: query
      schema:
        type: integer
        minimum: 1
        default: 1
      example: 1

    LimitParam:
      name: limit
      in: query
      schema:
        type: integer
        minimum: 1
        maximum: 100
        default: 20
      example: 20

    SearchParam:
      name: search
      in: query
      schema:
        type: string
        maxLength: 255
      example: "john"

  responses:
    BadRequest:
      description: Bad request
      content:
        application/json:
          schema:
            $ref: "#/components/schemas/ErrorResponse"

    Unauthorized:
      description: Unauthorized
      content:
        application/json:
          schema:
            $ref: "#/components/schemas/ErrorResponse"

    NotFound:
      description: Resource not found
      content:
        application/json:
          schema:
            $ref: "#/components/schemas/ErrorResponse"

    Conflict:
      description: Resource conflict
      content:
        application/json:
          schema:
            $ref: "#/components/schemas/ErrorResponse"

    InternalServerError:
      description: Internal server error
      content:
        application/json:
          schema:
            $ref: "#/components/schemas/ErrorResponse"

  securitySchemes:
    BearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT

security:
  - BearerAuth: []
```

## Type Generation

### Package.json Scripts

```json
{
  "scripts": {
    "openapi:lint": "spectral lint openapi/openapi.yaml",
    "openapi:bundle": "redocly bundle openapi/openapi.yaml -o openapi/dist/openapi.yaml",
    "openapi:types": "openapi-typescript openapi/dist/openapi.yaml -o src/types/openapi.d.ts",
    "openapi:docs": "redocly build-docs openapi/dist/openapi.yaml -o docs/api",
    "openapi:validate": "pnpm openapi:lint && pnpm openapi:bundle && pnpm openapi:types"
  }
}
```

### Generated Types Usage

```typescript
// src/types/openapi.d.ts (generated)
export interface User {
  id: number;
  first_name: string;
  last_name: string;
  email_address: string;
  role?: "admin" | "editor" | "viewer";
  is_active: boolean;
  created_at: string;
  updated_at: string;
}

export interface CreateUserRequest {
  first_name: string;
  last_name: string;
  email_address: string;
  role?: "admin" | "editor" | "viewer";
}

export interface UpdateUserRequest {
  first_name?: string;
  last_name?: string;
  email_address?: string;
  role?: "admin" | "editor" | "viewer";
  is_active?: boolean;
}

export interface UserResponse {
  success: boolean;
  data: User;
}

export interface UserListResponse {
  success: boolean;
  data: User[];
  pagination: Pagination;
}
```

## Implementation Using Generated Types

### Repository Interface

```typescript
// src/repositories/interfaces/user.repository.ts
import type {
  User,
  CreateUserRequest,
  UpdateUserRequest,
} from "@/types/openapi";

export interface UserRepository {
  findById(id: number): Promise<User | null>;
  findByEmail(email: string): Promise<User | null>;
  findAll(options?: {
    page?: number;
    limit?: number;
    search?: string;
  }): Promise<User[]>;
  create(data: CreateUserRequest): Promise<User>;
  update(id: number, data: UpdateUserRequest): Promise<User>;
  delete(id: number): Promise<void>;
  count(options?: { search?: string }): Promise<number>;
}
```

### Service Implementation

```typescript
// src/services/user.service.ts
import type {
  User,
  CreateUserRequest,
  UpdateUserRequest,
} from "@/types/openapi";
import type { UserRepository } from "@/repositories/interfaces/user.repository";

export class UserService {
  constructor(private userRepository: UserRepository) {}

  async createUser(data: CreateUserRequest): Promise<User> {
    // Business logic using OpenAPI types
    const existingUser = await this.userRepository.findByEmail(
      data.email_address,
    );
    if (existingUser) {
      throw new Error("User with this email already exists");
    }

    return await this.userRepository.create(data);
  }

  async updateUser(id: number, data: UpdateUserRequest): Promise<User> {
    const user = await this.userRepository.findById(id);
    if (!user) {
      throw new Error("User not found");
    }

    return await this.userRepository.update(id, data);
  }
}
```

### TRPC Router Implementation

```typescript
// src/server/api/routers/user.ts
import { z } from "zod";
import { createTRPCRouter, publicProcedure } from "@/server/api/trpc";
import { UserService } from "@/services/user.service";
import { createRepositories } from "@/repositories";
import type { CreateUserRequest, UpdateUserRequest } from "@/types/openapi";

const repositories = createRepositories();
const userService = new UserService(repositories.userRepository);

// Zod schemas that match OpenAPI spec
const CreateUserSchema = z.object({
  first_name: z.string().min(1).max(255),
  last_name: z.string().min(1).max(255),
  email_address: z.string().email().max(255),
  role: z.enum(["admin", "editor", "viewer"]).optional(),
});

const UpdateUserSchema = z.object({
  first_name: z.string().min(1).max(255).optional(),
  last_name: z.string().min(1).max(255).optional(),
  email_address: z.string().email().max(255).optional(),
  role: z.enum(["admin", "editor", "viewer"]).optional(),
  is_active: z.boolean().optional(),
});

export const userRouter = createTRPCRouter({
  create: publicProcedure
    .input(CreateUserSchema)
    .mutation(async ({ input }): Promise<CreateUserRequest> => {
      return await userService.createUser(input);
    }),

  update: publicProcedure
    .input(z.object({ id: z.number() }).merge(UpdateUserSchema))
    .mutation(async ({ input }): Promise<UpdateUserRequest> => {
      const { id, ...updateData } = input;
      return await userService.updateUser(id, updateData);
    }),
});
```

### Frontend Component

```typescript
// src/components/UserForm.tsx
import React, { useState } from "react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { api } from "@/trpc/react";
import type { CreateUserRequest } from "@/types/openapi";

interface UserFormProps {
  onSuccess?: () => void;
}

export const UserForm: React.FC<UserFormProps> = ({ onSuccess }) => {
  const [formData, setFormData] = useState<CreateUserRequest>({
    first_name: "",
    last_name: "",
    email_address: "",
    role: "viewer",
  });

  const createUser = api.user.create.useMutation({
    onSuccess: () => {
      onSuccess?.();
      setFormData({
        first_name: "",
        last_name: "",
        email_address: "",
        role: "viewer",
      });
    },
  });

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    createUser.mutate(formData);
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      <Input
        placeholder="First Name"
        value={formData.first_name}
        onChange={(e) =>
          setFormData({ ...formData, first_name: e.target.value })
        }
        required
      />
      <Input
        placeholder="Last Name"
        value={formData.last_name}
        onChange={(e) =>
          setFormData({ ...formData, last_name: e.target.value })
        }
        required
      />
      <Input
        placeholder="Email"
        type="email"
        value={formData.email_address}
        onChange={(e) =>
          setFormData({ ...formData, email_address: e.target.value })
        }
        required
      />
      <Button type="submit" disabled={createUser.isPending}>
        {createUser.isPending ? "Creating..." : "Create User"}
      </Button>
    </form>
  );
};
```

## Development Workflow

### 1. Design API First

```bash
# Edit OpenAPI specification
vim openapi/openapi.yaml

# Validate specification
pnpm openapi:lint
```

### 2. Generate Types

```bash
# Bundle and generate types
pnpm openapi:validate
```

### 3. Implement Code

```typescript
// Use generated types in implementation
import type { User, CreateUserRequest } from "@/types/openapi";
```

### 4. Validate Implementation

```bash
# Run tests to ensure implementation matches spec
pnpm test

# Check for type errors
pnpm type-check
```

## Best Practices

### OpenAPI Specification

- Use descriptive names and examples
- Include all required fields and constraints
- Define reusable components
- Use proper HTTP status codes
- Include error responses
- Document authentication requirements

### Type Generation

- Always regenerate types after spec changes
- Use strict TypeScript configuration
- Validate generated types match expectations
- Keep generated files in version control

### Implementation

- Use generated types throughout the codebase
- Validate input data matches OpenAPI schema
- Handle all defined error responses
- Follow the specification exactly
- Write tests that verify API contract compliance

## Tools and Dependencies

```json
{
  "devDependencies": {
    "@redocly/cli": "^1.0.0",
    "@stoplight/spectral-cli": "^6.0.0",
    "openapi-typescript": "^6.0.0"
  }
}
```
